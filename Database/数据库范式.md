# 数据库范式

> 整理 by 51.

设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。

## 第一范式（1NF）

**第一范式（1NF）强调列的原子性。**

第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，<u>所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项</u>。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。

在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。

## 第二范式（2NF）

**在1NF基础上，所有非主属性必须完全函数依赖于候选码（在1NF基础上消除非主属性对候选码的部分函数依赖）**

> **函数依赖**：设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不相等，则称<u>X函数确定Y</u>，或者<u>Y函数依赖于X</u>。记为X→Y。 
>
> **完全函数依赖**：在R(U)中，如果Y函数依赖于X，并且对于X的任何一个真子集X'，都有Y不函数依赖于X'， 则称Y对X完全函数依赖。
>
> **部分函数依赖**：在R(U)中，如果X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖。
>
> **候选键/候选码/候选关键字**：设K是一个R(U)中的属性或属性集合，若U完全函数依赖于K，则K为R的候选键(Candidate key)。通俗地说就是，能够确定全部属性的某个属性或某组属性，称为候选键。若候选键多于一个，则选定其中一个作为**主键**。
>
> **主属性**：包含在任何一个候选键中的属性，叫做主属性(Prime attribute)。不包含在任何候选键中的属性称为**非主属性**或**非键属性**或**非关键字段**。

满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求<u>数据库表中的每个实例或记录必须可以被唯一地区分，实体的属性完全函数依赖于主键</u>。

> **函数依赖与属性的关系**
>
> 设R(U)是属性集U上的关系模式，X、Y是U的子集。
>
> - 如果X和Y之间是一对一（1:1）关系，如学校和校长，则存在函数依赖X→Y和Y→X
> - 如果X和Y之间是一对多（1:n）关系，如年龄和姓名，则存在函数依赖Y→X
> - 如果X和Y之间是多对多（m:n）关系，如学生和课程，则X和Y之间不存在函数依赖

## 第三范式（3NF）

**在2NF基础上，任何非主属性不函数依赖于其它非主属性（在2NF基础上消除传递函数依赖）**

> **传递函数依赖**：在R(U)中，当且仅当X→Y, Y→Z，则称Z对X传递函数依赖。 

满足第三范式（3NF）必须满足第二范式（2NF）。第三范式（3NF）要求<u>一个关系中不包含已在其它关系已包含的非主键信息</u>。

例如，存在一个部门信息表，其中每个部门有部门编号、部门名称、部门简介等信息，那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中，否则就会有大量的数据冗余。

## 巴斯-科德范式（BCNF）

Boyce-Codd Normal Form（巴斯-科德范式）

> 定义：关系模式R<U,F>∈1NF，若X→Y且Y不是X的子集时X必含有候选码，则R<U,F>∈BCNF。

**在3NF基础上，任何主属性不能函数依赖于主码子集（在3NF基础上消除主属性对主码的部分函数依赖和传递函数依赖）**

由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：

- 所有非主属性对每一个码都是完全函数依赖。
- 所有主属性对每一个不包含它的码也是完全函数依赖。
- 没有任何属性完全函数依赖于非码的任何一组属性。

若R∈BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R∈3NF。

通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。

## 第四范式（4NF）

> 定义：关系模式R∈1NF，如果对于R的每个非平凡多值依赖X→→Y，X都含有候选码，则R∈4NF。

**4NF限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖（消除多值依赖）**

> **平凡函数依赖**：如果X→Y，但Y为X的子集，则称X→Y是平凡函数依赖。
>
> **非平凡函数依赖**：如果X→Y，但Y不为X的子集，则称X→Y是非平凡函数依赖。
>
> **多值依赖**：对于某个关系上的三个属性A, B, C。如果属性B、C的取值都不单一，同时B的取值与C无关，B依赖于A，随着A取值的变化可以取不同的值，记为A→→B。（函数依赖事实上是单值依赖，不能表达属性值之间的一对多关系）
>
> **平凡的多值依赖**：全集U=K+A，一个K可以对应于多个A，即K→→A。此时整个表就是一组一对多关系。
>
> **非平凡的多值依赖**：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B互相独立，即K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。

```
例：有这样一个用户联系方式表(ID, 用户ID, 固定电话, 移动电话)，这是一个非常简单的3NF表，不存在传递依赖。但在某些情况下，这样的表还是不合理的，比如说，用户有两个固定电话，两个移动电话：
ID			用户ID	固定电话	移动电话
1000001		USER1	0755-1234	13612345678
1000002		USER1	0755-5678	13687654321
这时此表就违反第四范式。其中用户ID→→固定电话，用户ID→→移动电话。

其中一个解决问题的方法：设计为用户联系方式表(ID, 用户ID, 电话号码, 电话号码类型)，这样就可以对每个用户处理不同类型的多个电话号码，而不会违反第四范式。
```

## 5NF（第五范式）

在4NF基础上，消除4NF中的连接依赖。

> **连接依赖**：设关系模式R、Ri的属性集是U、Ui，UiU(1≤i≤n)。若R每个容许的实例r均满足r=∏U1(r)∞...∞∏Un(r)则称R满足连接依赖，记作∞(R1,...,Rn)。若其中某个Ui=U，则称连接依赖是**平凡连接依赖**。 

